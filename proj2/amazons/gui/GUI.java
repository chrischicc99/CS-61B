package amazons.gui;

import amazons.Board;
import amazons.Move;
import amazons.Reporter;
import amazons.View;
import ucb.gui2.LayoutSpec;
import ucb.gui2.TopLevel;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

// This skeleton provides a bit of suggested structure.   It's up to you to
// discover what needs to be added.  You are NOT required to reproduce the
// GUI of the staff program.


/**
 * The GUI controller for an Amazons board and buttons.
 */
public class GUI extends TopLevel implements View, Reporter {

    /**
     * Minimum size of board in pixels.
     */
    private static final int MIN_SIZE = 500;
    /**
     * Pattern describing the 'seed' command's arguments.
     */
    private static final Pattern SEED_PATN =
            Pattern.compile("\\s*(-?\\d{1,18})\\s*$");
    /**
     * The board widget.
     */
    private BoardWidget _widget;
    /**
     * Queue of pending commands resulting from menu clicks and moves on the
     * board.  We use a blocking queue because the responses to clicks
     * on the board and on menus happen in parallel to the methods that
     * call readCommand, which therefore needs to wait for clicks to happen.
     */
    private ArrayBlockingQueue<String> _pendingCommands =
            new ArrayBlockingQueue<>(5);

    /**
     * A new window with given TITLE providing a view of an Amazons board.
     */
    public GUI(String title) {
        super(title, true);

        addMenuButton("Game->New", this::newGame);
        addMenuButton("Game->Quit", this::quit);
        addMenuButton("Settings->Seed", this::newSeed);
        addMenuButton("Settings->Auto Black", this::autoBlack);
        addMenuButton("Settings->Manual Black", this::manualBlack);
        addMenuButton("Settings->Auto White", this::autoWhite);
        addMenuButton("Settings->Manual White", this::manualWhite);

        _widget = new BoardWidget(_pendingCommands);
        add(_widget,
                new LayoutSpec("y", 1,
                        "height", 1,
                        "width", 3));
    }

    private void autoBlack(String s) {
        _widget.updateInformation(null, "auto");
        _pendingCommands.offer("auto black");
    }

    private void manualBlack(String s) {
        _widget.updateInformation(null, "manual");
        _pendingCommands.offer("manual black");
    }

    private void autoWhite(String s) {
        _widget.updateInformation("auto", null);
        _pendingCommands.offer("auto white");
    }

    private void manualWhite(String s) {
        _widget.updateInformation("manual", null);
        _pendingCommands.offer("manual white");
    }

    private void newGame(String s) {
        _pendingCommands.offer("new");
    }

    /**
     * Response to "Quit" button click.
     */
    private void quit(String dummy) {
        _pendingCommands.offer("quit");
    }

    /**
     * Response to "Seed" button click.
     */
    private void newSeed(String dummy) {
        String response =
                getTextInput("Enter new random seed.",
                        "New seed", "plain", "");
        if (response != null) {
            Matcher mat = SEED_PATN.matcher(response);
            if (mat.matches()) {
                _pendingCommands.offer(String.format("seed %s", mat.group(1)));
            } else {
                showMessage("Enter an integral seed value.", "Error", "error");
            }
        }
    }

    /**
     * Return the next command from our widget, waiting for it as necessary.
     * The BoardWidget uses _pendingCommands to queue up moves that it
     * receives.  Thie class uses _pendingCommands to queue up commands that
     * are generated by clicking on menu items.
     */
    String readCommand() {
        try {
            _widget.setMoveCollection(true);
            String cmnd = _pendingCommands.take();
            _widget.setMoveCollection(false);
            return cmnd;
        } catch (InterruptedException excp) {
            throw new Error("unexpected interrupt");
        }
    }

    @Override
    public void update(Board board) {
        _widget.update(board);
    }

    @Override
    public void reportError(String fmt, Object... args) {
        showMessage(String.format(fmt, args), "Amazons Error", "error");
    }

    @Override
    public void reportNote(String fmt, Object... args) {
        showMessage(String.format(fmt, args), "Amazons Message", "information");
    }

    @Override
    public void reportMove(Move unused) {
    }

}
